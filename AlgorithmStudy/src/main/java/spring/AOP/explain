    aop的底层实现-cglib动态代理和jdk动态代理 http://blog.csdn.net/dreamrealised/article/details/12885739
    aop是目前spring框架中的核心之一，在应用中具有非常重要的作用，也是spring其他组件的基础。它是一种面向切面编程的思想。关于aop的基础知识，相信多数童鞋都已经了如指掌，我们就略过这部分，来讲解下aop的核心功能的底层实现机制：如何用动态代理来实现切面拦截。
    aop的拦截功能是由java中的动态代理来实现的。说白了，就是在目标类的基础上增加切面逻辑，生成增强的目标类（该切面逻辑或者在目标类函数执行之前，或者目标类函数执行之后，或者在目标类函数抛出异常时候执行。
    不同的切入时机对应不同的interceptor的种类，如beforeadviseinterceptor，afteradviseinterceptor以及throwsadviseinterceptor等）。
    那么动态代理是如何实现将切面逻辑（advise）织入到目标类方法中去的呢？下面我们就来详细介绍并实现aop中用到的两种动态代理。
    aop的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。
    jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。总的来说，反射机制在生成类的过程中比较高效，
    而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。
    还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。
